// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protos/cassandra/backup/v1/backup.proto

package v1 // import "github.com/linuxuser586/apis/grpc/cassandra/backup/v1"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Downstream_Type int32

const (
	Downstream_COMMITLOG   Downstream_Type = 0
	Downstream_INCREMENTAL Downstream_Type = 1
	Downstream_SNAPSHOT    Downstream_Type = 2
)

var Downstream_Type_name = map[int32]string{
	0: "COMMITLOG",
	1: "INCREMENTAL",
	2: "SNAPSHOT",
}
var Downstream_Type_value = map[string]int32{
	"COMMITLOG":   0,
	"INCREMENTAL": 1,
	"SNAPSHOT":    2,
}

func (x Downstream_Type) String() string {
	return proto.EnumName(Downstream_Type_name, int32(x))
}
func (Downstream_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{0, 0}
}

type Downstream_ChunkSize int32

const (
	Downstream_FOUR_K  Downstream_ChunkSize = 0
	Downstream_ONE_K   Downstream_ChunkSize = 1
	Downstream_TWO_K   Downstream_ChunkSize = 3
	Downstream_EIGHT_K Downstream_ChunkSize = 4
)

var Downstream_ChunkSize_name = map[int32]string{
	0: "FOUR_K",
	1: "ONE_K",
	3: "TWO_K",
	4: "EIGHT_K",
}
var Downstream_ChunkSize_value = map[string]int32{
	"FOUR_K":  0,
	"ONE_K":   1,
	"TWO_K":   3,
	"EIGHT_K": 4,
}

func (x Downstream_ChunkSize) String() string {
	return proto.EnumName(Downstream_ChunkSize_name, int32(x))
}
func (Downstream_ChunkSize) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{0, 1}
}

type Downstream_HashType int32

const (
	Downstream_CRC32C Downstream_HashType = 0
)

var Downstream_HashType_name = map[int32]string{
	0: "CRC32C",
}
var Downstream_HashType_value = map[string]int32{
	"CRC32C": 0,
}

func (x Downstream_HashType) String() string {
	return proto.EnumName(Downstream_HashType_name, int32(x))
}
func (Downstream_HashType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{0, 2}
}

type Downstream struct {
	Type      Downstream_Type      `protobuf:"varint,1,opt,name=type,proto3,enum=linuxuser586.cassandra.backup.v1.Downstream_Type" json:"type,omitempty"`
	ChunkSize Downstream_ChunkSize `protobuf:"varint,2,opt,name=chunk_size,json=chunkSize,proto3,enum=linuxuser586.cassandra.backup.v1.Downstream_ChunkSize" json:"chunk_size,omitempty"`
	HashType  Downstream_HashType  `protobuf:"varint,3,opt,name=hash_type,json=hashType,proto3,enum=linuxuser586.cassandra.backup.v1.Downstream_HashType" json:"hash_type,omitempty"`
	Resume    *Downstream_Resume   `protobuf:"bytes,4,opt,name=resume" json:"resume,omitempty"`
}

func (m *Downstream) Reset()         { *m = Downstream{} }
func (m *Downstream) String() string { return proto.CompactTextString(m) }
func (*Downstream) ProtoMessage()    {}
func (*Downstream) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{0}
}
func (m *Downstream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Downstream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Downstream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Downstream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Downstream.Merge(dst, src)
}
func (m *Downstream) XXX_Size() int {
	return m.Size()
}
func (m *Downstream) XXX_DiscardUnknown() {
	xxx_messageInfo_Downstream.DiscardUnknown(m)
}

var xxx_messageInfo_Downstream proto.InternalMessageInfo

func (m *Downstream) GetType() Downstream_Type {
	if m != nil {
		return m.Type
	}
	return Downstream_COMMITLOG
}

func (m *Downstream) GetChunkSize() Downstream_ChunkSize {
	if m != nil {
		return m.ChunkSize
	}
	return Downstream_FOUR_K
}

func (m *Downstream) GetHashType() Downstream_HashType {
	if m != nil {
		return m.HashType
	}
	return Downstream_CRC32C
}

func (m *Downstream) GetResume() *Downstream_Resume {
	if m != nil {
		return m.Resume
	}
	return nil
}

type Downstream_Resume struct {
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	Position int64  `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	Path     string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *Downstream_Resume) Reset()         { *m = Downstream_Resume{} }
func (m *Downstream_Resume) String() string { return proto.CompactTextString(m) }
func (*Downstream_Resume) ProtoMessage()    {}
func (*Downstream_Resume) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{0, 0}
}
func (m *Downstream_Resume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Downstream_Resume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Downstream_Resume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Downstream_Resume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Downstream_Resume.Merge(dst, src)
}
func (m *Downstream_Resume) XXX_Size() int {
	return m.Size()
}
func (m *Downstream_Resume) XXX_DiscardUnknown() {
	xxx_messageInfo_Downstream_Resume.DiscardUnknown(m)
}

var xxx_messageInfo_Downstream_Resume proto.InternalMessageInfo

func (m *Downstream_Resume) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Downstream_Resume) GetPosition() int64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *Downstream_Resume) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type Upstream struct {
	// Types that are valid to be assigned to Payload:
	//	*Upstream_Meta_
	//	*Upstream_Chunk_
	Payload isUpstream_Payload `protobuf_oneof:"payload"`
}

func (m *Upstream) Reset()         { *m = Upstream{} }
func (m *Upstream) String() string { return proto.CompactTextString(m) }
func (*Upstream) ProtoMessage()    {}
func (*Upstream) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{1}
}
func (m *Upstream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Upstream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Upstream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Upstream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Upstream.Merge(dst, src)
}
func (m *Upstream) XXX_Size() int {
	return m.Size()
}
func (m *Upstream) XXX_DiscardUnknown() {
	xxx_messageInfo_Upstream.DiscardUnknown(m)
}

var xxx_messageInfo_Upstream proto.InternalMessageInfo

type isUpstream_Payload interface {
	isUpstream_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Upstream_Meta_ struct {
	Meta *Upstream_Meta `protobuf:"bytes,1,opt,name=meta,oneof"`
}
type Upstream_Chunk_ struct {
	Chunk *Upstream_Chunk `protobuf:"bytes,2,opt,name=chunk,oneof"`
}

func (*Upstream_Meta_) isUpstream_Payload()  {}
func (*Upstream_Chunk_) isUpstream_Payload() {}

func (m *Upstream) GetPayload() isUpstream_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Upstream) GetMeta() *Upstream_Meta {
	if x, ok := m.GetPayload().(*Upstream_Meta_); ok {
		return x.Meta
	}
	return nil
}

func (m *Upstream) GetChunk() *Upstream_Chunk {
	if x, ok := m.GetPayload().(*Upstream_Chunk_); ok {
		return x.Chunk
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Upstream) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Upstream_OneofMarshaler, _Upstream_OneofUnmarshaler, _Upstream_OneofSizer, []interface{}{
		(*Upstream_Meta_)(nil),
		(*Upstream_Chunk_)(nil),
	}
}

func _Upstream_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Upstream)
	// payload
	switch x := m.Payload.(type) {
	case *Upstream_Meta_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *Upstream_Chunk_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Chunk); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Upstream.Payload has unexpected type %T", x)
	}
	return nil
}

func _Upstream_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Upstream)
	switch tag {
	case 1: // payload.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Upstream_Meta)
		err := b.DecodeMessage(msg)
		m.Payload = &Upstream_Meta_{msg}
		return true, err
	case 2: // payload.chunk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Upstream_Chunk)
		err := b.DecodeMessage(msg)
		m.Payload = &Upstream_Chunk_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Upstream_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Upstream)
	// payload
	switch x := m.Payload.(type) {
	case *Upstream_Meta_:
		s := proto.Size(x.Meta)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Upstream_Chunk_:
		s := proto.Size(x.Chunk)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Upstream_Meta struct {
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	FileSize int64  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	Hash     string `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	Path     string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *Upstream_Meta) Reset()         { *m = Upstream_Meta{} }
func (m *Upstream_Meta) String() string { return proto.CompactTextString(m) }
func (*Upstream_Meta) ProtoMessage()    {}
func (*Upstream_Meta) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{1, 0}
}
func (m *Upstream_Meta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Upstream_Meta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Upstream_Meta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Upstream_Meta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Upstream_Meta.Merge(dst, src)
}
func (m *Upstream_Meta) XXX_Size() int {
	return m.Size()
}
func (m *Upstream_Meta) XXX_DiscardUnknown() {
	xxx_messageInfo_Upstream_Meta.DiscardUnknown(m)
}

var xxx_messageInfo_Upstream_Meta proto.InternalMessageInfo

func (m *Upstream_Meta) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Upstream_Meta) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *Upstream_Meta) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Upstream_Meta) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type Upstream_Chunk struct {
	Position int64  `protobuf:"varint,1,opt,name=position,proto3" json:"position,omitempty"`
	Data     []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Eof      bool   `protobuf:"varint,3,opt,name=eof,proto3" json:"eof,omitempty"`
}

func (m *Upstream_Chunk) Reset()         { *m = Upstream_Chunk{} }
func (m *Upstream_Chunk) String() string { return proto.CompactTextString(m) }
func (*Upstream_Chunk) ProtoMessage()    {}
func (*Upstream_Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{1, 1}
}
func (m *Upstream_Chunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Upstream_Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Upstream_Chunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Upstream_Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Upstream_Chunk.Merge(dst, src)
}
func (m *Upstream_Chunk) XXX_Size() int {
	return m.Size()
}
func (m *Upstream_Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Upstream_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_Upstream_Chunk proto.InternalMessageInfo

func (m *Upstream_Chunk) GetPosition() int64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *Upstream_Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Upstream_Chunk) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

type Restore struct {
	// Types that are valid to be assigned to Payload:
	//	*Restore_Downstream
	//	*Restore_Upstream
	Payload isRestore_Payload `protobuf_oneof:"payload"`
}

func (m *Restore) Reset()         { *m = Restore{} }
func (m *Restore) String() string { return proto.CompactTextString(m) }
func (*Restore) ProtoMessage()    {}
func (*Restore) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{2}
}
func (m *Restore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Restore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Restore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Restore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Restore.Merge(dst, src)
}
func (m *Restore) XXX_Size() int {
	return m.Size()
}
func (m *Restore) XXX_DiscardUnknown() {
	xxx_messageInfo_Restore.DiscardUnknown(m)
}

var xxx_messageInfo_Restore proto.InternalMessageInfo

type isRestore_Payload interface {
	isRestore_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Restore_Downstream struct {
	Downstream *Downstream `protobuf:"bytes,1,opt,name=downstream,oneof"`
}
type Restore_Upstream struct {
	Upstream *Upstream `protobuf:"bytes,2,opt,name=upstream,oneof"`
}

func (*Restore_Downstream) isRestore_Payload() {}
func (*Restore_Upstream) isRestore_Payload()   {}

func (m *Restore) GetPayload() isRestore_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Restore) GetDownstream() *Downstream {
	if x, ok := m.GetPayload().(*Restore_Downstream); ok {
		return x.Downstream
	}
	return nil
}

func (m *Restore) GetUpstream() *Upstream {
	if x, ok := m.GetPayload().(*Restore_Upstream); ok {
		return x.Upstream
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Restore) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Restore_OneofMarshaler, _Restore_OneofUnmarshaler, _Restore_OneofSizer, []interface{}{
		(*Restore_Downstream)(nil),
		(*Restore_Upstream)(nil),
	}
}

func _Restore_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Restore)
	// payload
	switch x := m.Payload.(type) {
	case *Restore_Downstream:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Downstream); err != nil {
			return err
		}
	case *Restore_Upstream:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Upstream); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Restore.Payload has unexpected type %T", x)
	}
	return nil
}

func _Restore_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Restore)
	switch tag {
	case 1: // payload.downstream
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Downstream)
		err := b.DecodeMessage(msg)
		m.Payload = &Restore_Downstream{msg}
		return true, err
	case 2: // payload.upstream
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Upstream)
		err := b.DecodeMessage(msg)
		m.Payload = &Restore_Upstream{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Restore_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Restore)
	// payload
	switch x := m.Payload.(type) {
	case *Restore_Downstream:
		s := proto.Size(x.Downstream)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Restore_Upstream:
		s := proto.Size(x.Upstream)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RestoreResponse struct {
	Fail    bool   `protobuf:"varint,1,opt,name=fail,proto3" json:"fail,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RestoreResponse) Reset()         { *m = RestoreResponse{} }
func (m *RestoreResponse) String() string { return proto.CompactTextString(m) }
func (*RestoreResponse) ProtoMessage()    {}
func (*RestoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{3}
}
func (m *RestoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RestoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreResponse.Merge(dst, src)
}
func (m *RestoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *RestoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreResponse proto.InternalMessageInfo

func (m *RestoreResponse) GetFail() bool {
	if m != nil {
		return m.Fail
	}
	return false
}

func (m *RestoreResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DeleteRequest struct {
	File string `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{4}
}
func (m *DeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRequest.Merge(dst, src)
}
func (m *DeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRequest proto.InternalMessageInfo

func (m *DeleteRequest) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

type DeleteResponse struct {
	Fail    bool   `protobuf:"varint,1,opt,name=fail,proto3" json:"fail,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_backup_8e86042d3050c8c7, []int{5}
}
func (m *DeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResponse.Merge(dst, src)
}
func (m *DeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResponse proto.InternalMessageInfo

func (m *DeleteResponse) GetFail() bool {
	if m != nil {
		return m.Fail
	}
	return false
}

func (m *DeleteResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*Downstream)(nil), "linuxuser586.cassandra.backup.v1.Downstream")
	proto.RegisterType((*Downstream_Resume)(nil), "linuxuser586.cassandra.backup.v1.Downstream.Resume")
	proto.RegisterType((*Upstream)(nil), "linuxuser586.cassandra.backup.v1.Upstream")
	proto.RegisterType((*Upstream_Meta)(nil), "linuxuser586.cassandra.backup.v1.Upstream.Meta")
	proto.RegisterType((*Upstream_Chunk)(nil), "linuxuser586.cassandra.backup.v1.Upstream.Chunk")
	proto.RegisterType((*Restore)(nil), "linuxuser586.cassandra.backup.v1.Restore")
	proto.RegisterType((*RestoreResponse)(nil), "linuxuser586.cassandra.backup.v1.RestoreResponse")
	proto.RegisterType((*DeleteRequest)(nil), "linuxuser586.cassandra.backup.v1.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "linuxuser586.cassandra.backup.v1.DeleteResponse")
	proto.RegisterEnum("linuxuser586.cassandra.backup.v1.Downstream_Type", Downstream_Type_name, Downstream_Type_value)
	proto.RegisterEnum("linuxuser586.cassandra.backup.v1.Downstream_ChunkSize", Downstream_ChunkSize_name, Downstream_ChunkSize_value)
	proto.RegisterEnum("linuxuser586.cassandra.backup.v1.Downstream_HashType", Downstream_HashType_name, Downstream_HashType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BackupServiceClient is the client API for BackupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackupServiceClient interface {
	StreamFrom(ctx context.Context, in *Downstream, opts ...grpc.CallOption) (BackupService_StreamFromClient, error)
	StreamTo(ctx context.Context, opts ...grpc.CallOption) (BackupService_StreamToClient, error)
	DeleteCommitLog(ctx context.Context, opts ...grpc.CallOption) (BackupService_DeleteCommitLogClient, error)
	DeleteIncremental(ctx context.Context, opts ...grpc.CallOption) (BackupService_DeleteIncrementalClient, error)
}

type backupServiceClient struct {
	cc *grpc.ClientConn
}

func NewBackupServiceClient(cc *grpc.ClientConn) BackupServiceClient {
	return &backupServiceClient{cc}
}

func (c *backupServiceClient) StreamFrom(ctx context.Context, in *Downstream, opts ...grpc.CallOption) (BackupService_StreamFromClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BackupService_serviceDesc.Streams[0], "/linuxuser586.cassandra.backup.v1.BackupService/StreamFrom", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupServiceStreamFromClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BackupService_StreamFromClient interface {
	Recv() (*Upstream, error)
	grpc.ClientStream
}

type backupServiceStreamFromClient struct {
	grpc.ClientStream
}

func (x *backupServiceStreamFromClient) Recv() (*Upstream, error) {
	m := new(Upstream)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *backupServiceClient) StreamTo(ctx context.Context, opts ...grpc.CallOption) (BackupService_StreamToClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BackupService_serviceDesc.Streams[1], "/linuxuser586.cassandra.backup.v1.BackupService/StreamTo", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupServiceStreamToClient{stream}
	return x, nil
}

type BackupService_StreamToClient interface {
	Send(*Restore) error
	Recv() (*RestoreResponse, error)
	grpc.ClientStream
}

type backupServiceStreamToClient struct {
	grpc.ClientStream
}

func (x *backupServiceStreamToClient) Send(m *Restore) error {
	return x.ClientStream.SendMsg(m)
}

func (x *backupServiceStreamToClient) Recv() (*RestoreResponse, error) {
	m := new(RestoreResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *backupServiceClient) DeleteCommitLog(ctx context.Context, opts ...grpc.CallOption) (BackupService_DeleteCommitLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BackupService_serviceDesc.Streams[2], "/linuxuser586.cassandra.backup.v1.BackupService/DeleteCommitLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupServiceDeleteCommitLogClient{stream}
	return x, nil
}

type BackupService_DeleteCommitLogClient interface {
	Send(*DeleteRequest) error
	Recv() (*DeleteResponse, error)
	grpc.ClientStream
}

type backupServiceDeleteCommitLogClient struct {
	grpc.ClientStream
}

func (x *backupServiceDeleteCommitLogClient) Send(m *DeleteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *backupServiceDeleteCommitLogClient) Recv() (*DeleteResponse, error) {
	m := new(DeleteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *backupServiceClient) DeleteIncremental(ctx context.Context, opts ...grpc.CallOption) (BackupService_DeleteIncrementalClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BackupService_serviceDesc.Streams[3], "/linuxuser586.cassandra.backup.v1.BackupService/DeleteIncremental", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupServiceDeleteIncrementalClient{stream}
	return x, nil
}

type BackupService_DeleteIncrementalClient interface {
	Send(*DeleteRequest) error
	Recv() (*DeleteResponse, error)
	grpc.ClientStream
}

type backupServiceDeleteIncrementalClient struct {
	grpc.ClientStream
}

func (x *backupServiceDeleteIncrementalClient) Send(m *DeleteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *backupServiceDeleteIncrementalClient) Recv() (*DeleteResponse, error) {
	m := new(DeleteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BackupServiceServer is the server API for BackupService service.
type BackupServiceServer interface {
	StreamFrom(*Downstream, BackupService_StreamFromServer) error
	StreamTo(BackupService_StreamToServer) error
	DeleteCommitLog(BackupService_DeleteCommitLogServer) error
	DeleteIncremental(BackupService_DeleteIncrementalServer) error
}

func RegisterBackupServiceServer(s *grpc.Server, srv BackupServiceServer) {
	s.RegisterService(&_BackupService_serviceDesc, srv)
}

func _BackupService_StreamFrom_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Downstream)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackupServiceServer).StreamFrom(m, &backupServiceStreamFromServer{stream})
}

type BackupService_StreamFromServer interface {
	Send(*Upstream) error
	grpc.ServerStream
}

type backupServiceStreamFromServer struct {
	grpc.ServerStream
}

func (x *backupServiceStreamFromServer) Send(m *Upstream) error {
	return x.ServerStream.SendMsg(m)
}

func _BackupService_StreamTo_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BackupServiceServer).StreamTo(&backupServiceStreamToServer{stream})
}

type BackupService_StreamToServer interface {
	Send(*RestoreResponse) error
	Recv() (*Restore, error)
	grpc.ServerStream
}

type backupServiceStreamToServer struct {
	grpc.ServerStream
}

func (x *backupServiceStreamToServer) Send(m *RestoreResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *backupServiceStreamToServer) Recv() (*Restore, error) {
	m := new(Restore)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BackupService_DeleteCommitLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BackupServiceServer).DeleteCommitLog(&backupServiceDeleteCommitLogServer{stream})
}

type BackupService_DeleteCommitLogServer interface {
	Send(*DeleteResponse) error
	Recv() (*DeleteRequest, error)
	grpc.ServerStream
}

type backupServiceDeleteCommitLogServer struct {
	grpc.ServerStream
}

func (x *backupServiceDeleteCommitLogServer) Send(m *DeleteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *backupServiceDeleteCommitLogServer) Recv() (*DeleteRequest, error) {
	m := new(DeleteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BackupService_DeleteIncremental_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BackupServiceServer).DeleteIncremental(&backupServiceDeleteIncrementalServer{stream})
}

type BackupService_DeleteIncrementalServer interface {
	Send(*DeleteResponse) error
	Recv() (*DeleteRequest, error)
	grpc.ServerStream
}

type backupServiceDeleteIncrementalServer struct {
	grpc.ServerStream
}

func (x *backupServiceDeleteIncrementalServer) Send(m *DeleteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *backupServiceDeleteIncrementalServer) Recv() (*DeleteRequest, error) {
	m := new(DeleteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BackupService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "linuxuser586.cassandra.backup.v1.BackupService",
	HandlerType: (*BackupServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamFrom",
			Handler:       _BackupService_StreamFrom_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamTo",
			Handler:       _BackupService_StreamTo_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DeleteCommitLog",
			Handler:       _BackupService_DeleteCommitLog_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DeleteIncremental",
			Handler:       _BackupService_DeleteIncremental_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "protos/cassandra/backup/v1/backup.proto",
}

func (m *Downstream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Downstream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Type))
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.ChunkSize))
	}
	if m.HashType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.HashType))
	}
	if m.Resume != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Resume.Size()))
		n1, err := m.Resume.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Downstream_Resume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Downstream_Resume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if m.Position != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Position))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *Upstream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Upstream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		nn2, err := m.Payload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *Upstream_Meta_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Meta.Size()))
		n3, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Upstream_Chunk_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Chunk != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Chunk.Size()))
		n4, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Upstream_Meta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Upstream_Meta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.FileSize))
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *Upstream_Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Upstream_Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Position))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Eof {
		dAtA[i] = 0x18
		i++
		if m.Eof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Restore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Restore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		nn5, err := m.Payload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *Restore_Downstream) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Downstream != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Downstream.Size()))
		n6, err := m.Downstream.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Restore_Upstream) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Upstream != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Upstream.Size()))
		n7, err := m.Upstream.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *RestoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fail {
		dAtA[i] = 0x8
		i++
		if m.Fail {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.File) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	return i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fail {
		dAtA[i] = 0x8
		i++
		if m.Fail {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func encodeVarintBackup(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Downstream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBackup(uint64(m.Type))
	}
	if m.ChunkSize != 0 {
		n += 1 + sovBackup(uint64(m.ChunkSize))
	}
	if m.HashType != 0 {
		n += 1 + sovBackup(uint64(m.HashType))
	}
	if m.Resume != nil {
		l = m.Resume.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}

func (m *Downstream_Resume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovBackup(uint64(m.Position))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}

func (m *Upstream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	return n
}

func (m *Upstream_Meta_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}
func (m *Upstream_Chunk_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chunk != nil {
		l = m.Chunk.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}
func (m *Upstream_Meta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovBackup(uint64(m.FileSize))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}

func (m *Upstream_Chunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovBackup(uint64(m.Position))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.Eof {
		n += 2
	}
	return n
}

func (m *Restore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	return n
}

func (m *Restore_Downstream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Downstream != nil {
		l = m.Downstream.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}
func (m *Restore_Upstream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Upstream != nil {
		l = m.Upstream.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}
func (m *RestoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fail {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}

func (m *DeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fail {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	return n
}

func sovBackup(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBackup(x uint64) (n int) {
	return sovBackup(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Downstream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Downstream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Downstream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Downstream_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (Downstream_ChunkSize(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashType", wireType)
			}
			m.HashType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashType |= (Downstream_HashType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resume == nil {
				m.Resume = &Downstream_Resume{}
			}
			if err := m.Resume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Downstream_Resume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Upstream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Upstream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Upstream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Upstream_Meta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Upstream_Meta_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Upstream_Chunk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Upstream_Chunk_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Upstream_Meta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Meta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Meta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Upstream_Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eof = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Restore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Restore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Restore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downstream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Downstream{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Restore_Downstream{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Upstream{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Restore_Upstream{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fail = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fail = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBackup(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBackup
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBackup
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBackup(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBackup = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBackup   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protos/cassandra/backup/v1/backup.proto", fileDescriptor_backup_8e86042d3050c8c7)
}

var fileDescriptor_backup_8e86042d3050c8c7 = []byte{
	// 762 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x95, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x86, 0x49, 0x8b, 0x96, 0xc8, 0x23, 0x5f, 0xd8, 0x59, 0x14, 0x82, 0x0a, 0x08, 0x06, 0xbb,
	0xa8, 0x5b, 0x14, 0xd4, 0xc5, 0xb5, 0x51, 0x74, 0xd1, 0xc2, 0x96, 0x65, 0x53, 0x90, 0x25, 0x15,
	0x23, 0x09, 0x01, 0xb2, 0x11, 0xc6, 0xd4, 0x58, 0x64, 0x2c, 0x5e, 0xc2, 0x21, 0x9d, 0xd8, 0xc8,
	0x43, 0xe4, 0x41, 0x82, 0x3c, 0x47, 0x96, 0x5e, 0x06, 0xc8, 0x26, 0xb0, 0x91, 0xf7, 0x08, 0x38,
	0x24, 0x65, 0x1b, 0x09, 0x62, 0x29, 0x8b, 0xec, 0x7e, 0x0e, 0xe7, 0xff, 0xcf, 0x99, 0xef, 0x0c,
	0x41, 0xf8, 0xcd, 0x0f, 0xbc, 0xd0, 0x63, 0x55, 0x93, 0x30, 0x46, 0xdc, 0x49, 0x40, 0xaa, 0xa7,
	0xc4, 0x3c, 0x8f, 0xfc, 0xea, 0x45, 0x3d, 0x55, 0x3a, 0xdf, 0x81, 0xb6, 0x66, 0xb6, 0x1b, 0xbd,
	0x8c, 0x18, 0x0d, 0x76, 0xff, 0xde, 0xd3, 0xe7, 0xdb, 0xf5, 0x74, 0xd3, 0x45, 0x5d, 0x7b, 0x23,
	0x01, 0x1c, 0x7a, 0x2f, 0x5c, 0x16, 0x06, 0x94, 0x38, 0xa8, 0x05, 0x52, 0x78, 0xe9, 0xd3, 0x92,
	0xb8, 0x25, 0x6e, 0x6f, 0x34, 0xea, 0xfa, 0x63, 0x7e, 0xfd, 0xce, 0xab, 0x0f, 0x2f, 0x7d, 0x8a,
	0xb9, 0x1d, 0x8d, 0x00, 0x4c, 0x2b, 0x72, 0xcf, 0xc7, 0xcc, 0xbe, 0xa2, 0xa5, 0x15, 0x1e, 0xb6,
	0xb7, 0x54, 0x58, 0x33, 0xb6, 0x0f, 0xec, 0x2b, 0x8a, 0x15, 0x33, 0x93, 0x08, 0x83, 0x62, 0x11,
	0x66, 0x8d, 0x79, 0x8b, 0x39, 0x9e, 0xba, 0xbb, 0x54, 0xaa, 0x41, 0x98, 0xc5, 0xdb, 0x94, 0xad,
	0x54, 0xa1, 0x0e, 0xe4, 0x03, 0xca, 0x22, 0x87, 0x96, 0xa4, 0x2d, 0x71, 0xbb, 0xd8, 0xd8, 0x59,
	0x2a, 0x10, 0x73, 0x2b, 0x4e, 0x23, 0xca, 0x23, 0xc8, 0x27, 0x2b, 0xe8, 0x17, 0x50, 0xce, 0xec,
	0x19, 0x1d, 0xbb, 0xc4, 0x49, 0x68, 0x2a, 0x58, 0x8e, 0x17, 0x7a, 0xc4, 0xa1, 0xa8, 0x0c, 0xb2,
	0xef, 0x31, 0x3b, 0xb4, 0x3d, 0x97, 0xc3, 0xc9, 0xe1, 0xf9, 0x33, 0x42, 0x20, 0xf9, 0x24, 0xb4,
	0xf8, 0xf1, 0x14, 0xcc, 0xb5, 0xf6, 0x17, 0x48, 0xbc, 0xd7, 0x75, 0x50, 0x9a, 0xfd, 0x6e, 0xb7,
	0x3d, 0x3c, 0xe9, 0x1f, 0xab, 0x02, 0xda, 0x84, 0x62, 0xbb, 0xd7, 0xc4, 0xad, 0x6e, 0xab, 0x37,
	0xdc, 0x3f, 0x51, 0x45, 0xb4, 0x06, 0xf2, 0xa0, 0xb7, 0xff, 0xff, 0xc0, 0xe8, 0x0f, 0xd5, 0x15,
	0xed, 0x1f, 0x50, 0xe6, 0x14, 0x11, 0x40, 0xfe, 0xa8, 0x3f, 0xc2, 0xe3, 0x8e, 0x2a, 0x20, 0x05,
	0x56, 0xfb, 0xbd, 0xd6, 0xb8, 0xa3, 0x8a, 0xb1, 0x1c, 0x3e, 0xe9, 0x8f, 0x3b, 0x6a, 0x0e, 0x15,
	0xa1, 0xd0, 0x6a, 0x1f, 0x1b, 0xc3, 0x71, 0x47, 0x95, 0xb4, 0x9f, 0x41, 0xce, 0x58, 0xc5, 0xd6,
	0x26, 0x6e, 0xee, 0x34, 0x9a, 0xaa, 0xa0, 0x7d, 0x58, 0x01, 0x79, 0xe4, 0xdf, 0x5d, 0x16, 0x87,
	0x86, 0x84, 0x1f, 0xaf, 0xd8, 0xa8, 0x3e, 0x0e, 0x2e, 0x73, 0xea, 0x5d, 0x1a, 0x12, 0x43, 0xc0,
	0xdc, 0x8e, 0x0c, 0x58, 0xe5, 0x23, 0xe6, 0x28, 0x8a, 0x8d, 0xda, 0x12, 0x39, 0xfc, 0x7c, 0x86,
	0x80, 0x93, 0x80, 0xb2, 0x05, 0x52, 0x9c, 0xfc, 0x6d, 0xf8, 0xd9, 0xcb, 0xf9, 0xd5, 0xcc, 0x25,
	0x2f, 0x39, 0x26, 0x04, 0x52, 0x7c, 0x33, 0x32, 0xfa, 0xb1, 0x9e, 0x4f, 0x44, 0xba, 0x9b, 0x48,
	0xb9, 0x0d, 0xab, 0xbc, 0xf6, 0x83, 0x51, 0x8a, 0x5f, 0x8e, 0x72, 0x42, 0x42, 0xc2, 0x8b, 0xac,
	0x61, 0xae, 0x91, 0x0a, 0x39, 0xea, 0x9d, 0xf1, 0x7c, 0x19, 0xc7, 0xf2, 0x40, 0x81, 0x82, 0x4f,
	0x2e, 0x67, 0x1e, 0x99, 0x68, 0x6f, 0x45, 0x28, 0x60, 0xca, 0x42, 0x2f, 0xa0, 0xa8, 0x07, 0x30,
	0x99, 0xdf, 0xb3, 0x14, 0xf1, 0x9f, 0xcb, 0xdc, 0x4d, 0x43, 0xc0, 0xf7, 0x12, 0x90, 0x01, 0x72,
	0x94, 0x62, 0x4b, 0x41, 0xff, 0xb1, 0x38, 0x68, 0x43, 0xc0, 0x73, 0xf7, 0xfd, 0x86, 0xff, 0x83,
	0xcd, 0xb4, 0x5f, 0x4c, 0x99, 0xef, 0xb9, 0x8c, 0x13, 0x3c, 0x23, 0xf6, 0x8c, 0x77, 0x2c, 0x63,
	0xae, 0x51, 0x09, 0x0a, 0x0e, 0x65, 0x8c, 0x4c, 0x13, 0xe0, 0x0a, 0xce, 0x1e, 0xb5, 0x5f, 0x61,
	0xfd, 0x90, 0xce, 0x68, 0x48, 0x31, 0x7d, 0x1e, 0x51, 0x16, 0x72, 0xbb, 0x3d, 0xcb, 0xa6, 0xc6,
	0xb5, 0xf6, 0x2f, 0x6c, 0x64, 0x9b, 0xbe, 0xa7, 0x48, 0xe3, 0x53, 0x0e, 0xd6, 0x0f, 0xf8, 0x99,
	0x06, 0x34, 0xb8, 0xb0, 0x4d, 0x8a, 0x9e, 0x01, 0x0c, 0xf8, 0x61, 0x8e, 0x02, 0xcf, 0x41, 0x4b,
	0x61, 0x2d, 0x2f, 0x81, 0x4d, 0x13, 0x6a, 0x22, 0x72, 0x41, 0x4e, 0x6a, 0x0d, 0x3d, 0xf4, 0xfb,
	0xe3, 0xde, 0x94, 0x67, 0xb9, 0xbe, 0xf0, 0xd6, 0x8c, 0x8a, 0x26, 0x6c, 0x8b, 0x35, 0x11, 0x5d,
	0xc1, 0x66, 0x42, 0xab, 0xe9, 0x39, 0x8e, 0x1d, 0x9e, 0x78, 0x53, 0xb4, 0xc0, 0xa7, 0xf9, 0x60,
	0x0a, 0xe5, 0xda, 0xe2, 0x86, 0x07, 0xb5, 0x5f, 0xc1, 0x4f, 0xc9, 0x7a, 0xdb, 0x35, 0x03, 0xea,
	0x50, 0x37, 0x24, 0xb3, 0x1f, 0x56, 0xfd, 0xa0, 0xff, 0xee, 0xa6, 0x22, 0x5e, 0xdf, 0x54, 0xc4,
	0x8f, 0x37, 0x15, 0xf1, 0xf5, 0x6d, 0x45, 0xb8, 0xbe, 0xad, 0x08, 0xef, 0x6f, 0x2b, 0xc2, 0xd3,
	0xdd, 0xa9, 0x1d, 0x5a, 0xd1, 0xa9, 0x6e, 0x7a, 0x4e, 0xf5, 0x7e, 0x76, 0x95, 0xf8, 0x36, 0xab,
	0x4e, 0x03, 0xdf, 0xfc, 0xda, 0xbf, 0xf4, 0x34, 0xcf, 0xff, 0xa2, 0x3b, 0x9f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x60, 0xcb, 0xcd, 0x64, 0x70, 0x07, 0x00, 0x00,
}
